"""
rat_command.py - Handles Command registration and Command-triggering IRC events

Copyright (c) 2018 The Fuel Rats Mischief,
All rights reserved.

Licensed under the BSD 3-Clause License.

See LICENSE.md

This module is built on top of the Pydle system.

"""

from functools import wraps
import logging
from itertools import zip_longest
from typing import Sequence, List

from Modules.trigger import Trigger
import config

# set the logger for handlers

log = logging.getLogger(f'{config.Logging.base_logger}.handlers')


class CommandException(Exception):
    """
    base Command Exception
    """
    pass


class InvalidCommandException(CommandException):
    """
    invoked command failed validation
    """
    pass


class CommandNotFoundException(CommandException):
    """
    Command not found.
    """
    pass


class NameCollisionException(CommandException):
    """
    Someone attempted to register a command already registered.
    """
    pass


class _Command:
    """
    Command object, to only be generated by `Commands.command()` decorator below
    """
    pass


class _Param(object):
    """Helper object used by `BaseCommandHandler.parametrize`"""
    CASE = 0
    FIND = 1
    RAT = 2
    WORD = 3

    def __init__(self, type: int, create: bool=False, optional: bool=False):
        assert 0 <= type <= 3

        self.type = type
        self.create = create
        self.optional = optional


class Commands:
    """
    Handles command registration and execution
    """

    ####
    # logger facility
    log = logging.getLogger(f"{config.Logging.base_logger}.commands")
    ####
    # commands registered with @command will populate this dict
    _registered_commands = {}

    ####
    # character/s that must prefix a message for it to be parsed as a command.
    prefix = '!'

    ####
    # Pydle bot instance. #FIXME set value during MechaClient init!
    bot = None

    @classmethod
    async def trigger(cls, message: str, sender: str, channel: str):
        """
        Invoke a command, passing args and kwargs to the called function
        :param message: triggers message to invoke
        :param sender: author of triggering message
        :param channel: channel of triggering message
        :return: bool command
        """
        log.debug("trigger called!")
        if cls._registered_commands is None:
            cls.log.critical(" registered commands dict somehow was set to None")
            raise CommandException("registered_commands is None!")
        if not cls.bot:
            # someone didn't set me.
            raise CommandException(f"cls.bot is not set. (value = {cls.bot}")

        cls.log.debug(f"triggered! message is {message}")

        if not message:
            raise InvalidCommandException(f"Command required, got {message}")
        elif not message.startswith(cls.prefix):
            log.debug(f"ignoring message{message} as it does not start with my prefix.")
            return None
        else:
            raw_command: str = message.lstrip(cls.prefix)  # remove command prefix

            words = []
            words_eol = []
            remaining = raw_command
            while True:
                words_eol.append(remaining)
                try:
                    word, remaining = remaining.split(maxsplit=1)
                except ValueError:
                    # we couldn't split -> only one word left
                    words.append(remaining)
                    break
                else:
                    words.append(word)

            trigger = Trigger.from_bot_user(cls.bot, sender, channel)

            cls.log.debug(f"words={words}\ncommand={words[0]}\nargs={words[1:]}")
            if words[0] not in cls._registered_commands:
                cls.log.error(f"unable to find command.{words[0]}")
                raise CommandNotFoundException(f"Unable to find command {words[0]}")
            else:
                cls.log.debug("found command, invoking...")
                cmd = cls.get_command(words[0])
                return await cmd(cls.bot, trigger, words, words_eol)

    @classmethod
    def _register(cls, func, names: list or str) -> bool:
        """
        Register a new command
        :param func: function
        :param names: names to register
        :return: success
        """
        if isinstance(names, str):
            names = [names]  # idiot proofing

        if func is None or not callable(func):
            # command not callable
            return False

        else:
            for alias in names:
                if alias in cls._registered_commands:
                    # command already registered
                    raise NameCollisionException(f"attempted to re-register command(s) {alias}")
                else:
                    formed_dict = {alias: func}
                    cls._registered_commands.update(formed_dict)

            return True

    @classmethod
    def _flush(cls)->None:
        """
        Flushes registered commands
        Probably useless outside testing...
        :return: None
        """
        cls._registered_commands = {}

    @classmethod
    def command(cls, *aliases):
        # stuff that occurs here executes when the wrapped command is first computed
        # use this space for command registration

        def real_decorator(func):
            # this also only executes during intial wrap
            # methinks this is where command reg should occur?
            cls.log.debug("inside real_decorator")
            cls.log.debug(f"Congratulations.  You decorated a function that does something with {aliases}")

            @wraps(func)
            async def wrapper(bot, trigger, words, words_eol):
                cls.log.debug("inside wrapper")
                try:
                    # This works if we're the bottommost decorator (calling the command function directly)
                    return await func(bot, trigger)
                except TypeError:
                    # Otherwise, we're giving all the things to the underlying wrapper (be it from parametrize or sth)
                    return await func(bot, trigger, words, words_eol)

            # we want to register the wrapper, not the underlying function
            cls.log.debug(f"registering command with aliases: {aliases}...")
            if not cls._register(wrapper, aliases):
                raise InvalidCommandException("unable to register commands.")
            cls.log.debug(f"Success! done registering commands {aliases}!")

            return wrapper
        return real_decorator

    @classmethod
    def parametrize(cls, params: str, usage: str):
        """
        Provides underlying command coroutine with predictable and easy-to-use arguments.

        Arguments:
            params: String of parameters which will each be translated into an argument. Some of these are TODO.
                'c': Argument will be the `Rescue` object returned by `self.board.find`.
                'C': Same as 'c', but creates the case if it doesn't exist.
                'f': Same as 'c', but returning `(Rescue, bool)` as returned by `self.board.find`.
                'F': Same as 'C', but returning `(Rescue, bool)` as returned by `self.board.find`.
                'r': Argument will be the `Rat` object found.
                'w': Argument will be a single word (separated by whitespace).

                '?': Marks the previous parameter as optional. If it isn't provided, don't complain. Optional parameters
                    may not precede mandatory ones. Argument will be None if not provided.
            usage (str): String representing the correct usage of this command. Will be printed if it is used wrongly.

        Example:
            ``
            @parametrize("cc?")
            async def some_command(bot, trigger, rescue1, rescue2_or_none_if_not_provided): pass
            ``
        """
        params = cls._prettify_params(params)

        def decorator(coro):
            @wraps(coro)
            async def new_coro(bot, trigger: Trigger, words: Sequence[str], words_eol: Sequence[str]):
                args = [bot, trigger]

                for param, arg in zip_longest(params, words[1:]):
                    if param is None:
                        # too many arguments provided
                        return trigger.reply(f"usage: {config.Commands.trigger}{words[0]} {usage}")
                    elif arg is None:
                        # no more arguments provided
                        if param.optional:
                            args.append(None)
                        else:
                            return trigger.reply(f"usage: {config.Commands.trigger}{words[0]} {usage}")

                    elif param.type in (param.CASE, param.FIND):
                        # waiting on the rescue board for this
                        raise NotImplementedError("Rescue parameters are not implemented yet")
                    elif param.type == param.RAT:
                        raise NotImplementedError("Rat parameters are not implemented yet")
                    elif param.type == param.WORD:
                        args.append(arg)

                return await coro(*args)
            return new_coro
        return decorator

    @staticmethod
    def _prettify_params(params: str) -> List[_Param]:
        """Helper method for `parametrize`"""
        pretty_params = []
        for i, param in enumerate(params):
            if param in "cC":
                pretty_params.append(_Param(_Param.CASE))
            elif param in "fF":
                pretty_params.append(_Param(_Param.FIND))
            elif param == "r":
                pretty_params.append(_Param(_Param.RAT))
            elif param == "w":
                pretty_params.append(_Param(_Param.WORD))
            elif param == "?":
                continue
            else:
                raise ValueError("unrecognized command parameter: {}".format(param))

            if param in "CF":
                pretty_params[-1].create = True
            if i < len(params) - 1 and params[i + 1] == "?":
                pretty_params[-1].optional = True

        return pretty_params

    @classmethod
    def get_command(cls, name: str):
        # remove the prefix.
        name = name.strip(cls.prefix)
        # see if its a command
        if name in cls._registered_commands:
            cls.log.debug("command found!")
            return cls._registered_commands[name]
        else:
            return None
